import { readFile } from "node:fs/promises";
import { withCircuitBreaker } from "../infra/circuitBreakerStore.js";

const API_BASE = "https://www.googleapis.com/youtube/v3";
const OAUTH_BASE = "https://oauth2.googleapis.com/token";

function publishMode() {
  return process.env.YOUTUBE_PUBLISH_MODE || "mock";
}

function directAccessToken() {
  return process.env.YOUTUBE_ACCESS_TOKEN || "";
}

async function getAccessToken() {
  const direct = directAccessToken();
  if (direct) return direct;

  const clientId = process.env.GOOGLE_CLIENT_ID || "";
  const clientSecret = process.env.GOOGLE_CLIENT_SECRET || "";
  const refreshToken = process.env.GOOGLE_REFRESH_TOKEN || "";

  if (!clientId || !clientSecret || !refreshToken) {
    throw new Error("YOUTUBE_ACCESS_TOKEN_REQUIRED");
  }

  const body = new URLSearchParams({
    client_id: clientId,
    client_secret: clientSecret,
    refresh_token: refreshToken,
    grant_type: "refresh_token"
  });

  const res = await withCircuitBreaker("youtube.oauth", async () => {
    const response = await fetch(OAUTH_BASE, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body
    });
    if (!response.ok) {
      throw new Error(`YOUTUBE_OAUTH_HTTP_${response.status}`);
    }
    return response;
  });

  const json = await res.json();
  if (!json.access_token) {
    throw new Error("YOUTUBE_ACCESS_TOKEN_REQUIRED");
  }

  return json.access_token;
}

async function apiGet(url) {
  return withCircuitBreaker("youtube.api", async () => {
    const token = await getAccessToken();
    const res = await fetch(url, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    if (!res.ok) {
      throw new Error(`YOUTUBE_HTTP_${res.status}`);
    }
    return res.json();
  });
}

export async function fetchYouTubeVideoStats(videoId) {
  if (!videoId) {
    throw new Error("VIDEO_ID_REQUIRED");
  }

  if (publishMode() !== "live") {
    return {
      videoId,
      viewCount: 1200,
      likeCount: 96,
      commentCount: 14,
      favoriteCount: 0,
      fetchedAt: new Date().toISOString()
    };
  }

  const url = `${API_BASE}/videos?part=statistics&id=${encodeURIComponent(videoId)}`;
  const json = await apiGet(url);
  const item = Array.isArray(json.items) ? json.items[0] : null;

  if (!item) {
    throw new Error("YOUTUBE_VIDEO_NOT_FOUND");
  }

  const stats = item.statistics || {};

  return {
    videoId,
    viewCount: Number(stats.viewCount || 0),
    likeCount: Number(stats.likeCount || 0),
    commentCount: Number(stats.commentCount || 0),
    favoriteCount: Number(stats.favoriteCount || 0),
    fetchedAt: new Date().toISOString()
  };
}

export async function publishVideoToYouTube({
  publishId,
  topic,
  title,
  description,
  videoAssetPath
}) {
  if (!publishId) {
    throw new Error("PUBLISH_ID_REQUIRED");
  }

  if (publishMode() !== "live") {
    return {
      videoId: `mock_${publishId}`,
      youtubeSyncStatus: "mock_published",
      youtubePublishedAt: new Date().toISOString()
    };
  }

  if (!videoAssetPath) {
    throw new Error("VIDEO_ASSET_PATH_REQUIRED");
  }

  const token = await getAccessToken();
  const videoBytes = await readFile(videoAssetPath);

  const initRes = await withCircuitBreaker("youtube.upload", async () => {
    const response = await fetch(`${API_BASE}/videos?part=snippet,status&uploadType=resumable`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json; charset=UTF-8",
        "X-Upload-Content-Type": "video/mp4",
        "X-Upload-Content-Length": String(videoBytes.byteLength)
      },
      body: JSON.stringify({
        snippet: {
          title: title || `${topic || "video"}`,
          description: description || "Generated by you7li"
        },
        status: {
          privacyStatus: process.env.YOUTUBE_PRIVACY_STATUS || "unlisted"
        }
      })
    });
    if (!response.ok) {
      throw new Error(`YOUTUBE_UPLOAD_INIT_HTTP_${response.status}`);
    }
    return response;
  });

  const uploadUrl = initRes.headers.get("location");
  if (!uploadUrl) {
    throw new Error("YOUTUBE_UPLOAD_URL_MISSING");
  }

  const uploadRes = await withCircuitBreaker("youtube.upload", async () => {
    const response = await fetch(uploadUrl, {
      method: "PUT",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "video/mp4"
      },
      body: videoBytes
    });
    if (!response.ok) {
      throw new Error(`YOUTUBE_UPLOAD_HTTP_${response.status}`);
    }
    return response;
  });

  const uploaded = await uploadRes.json();
  const videoId = uploaded?.id;

  if (!videoId) {
    throw new Error("YOUTUBE_VIDEO_ID_MISSING");
  }

  return {
    videoId,
    youtubeSyncStatus: "published",
    youtubePublishedAt: new Date().toISOString()
  };
}
